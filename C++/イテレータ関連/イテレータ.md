# イテレータとは

配列やmapなどのコンテナの各要素に対して順番に処理を行うときにイテレータを用いることができる。
いままでにもsortなんかで使ってきていた`配列.begin()`や`配列.end()`もイテレータ！  
配列に対するイテレータは「各要素を指すもの」として考えることができる。

```
#include <bits/stdc++.h>
using namespace std;

int main() {
  vector<int> a = {3, 1, 5, 6, 7, 2, 4};

  auto itr1 = a.begin();  // aの先頭を指すイテレータ
  itr1 = itr1 + 2;        // a[2]を指すイテレータ
  auto itr2 = itr1 + 4;   // 末尾の要素(a[6])を指すイテレータ

  cout << *itr1 << endl;  // itr1が指す要素(a[2])へのアクセス
  cout << *itr2 << endl;  // itr2が指す要素(a[6])へのアクセス
}

```

配列だと`a[i]`のような形でインデックスを指定して書くことができるのであまりイテレータを使う機会はないが，  
イテレータには「配列以外のデータ構造に対しても同じように扱える」というメリットがある。

## イテレータの型はauto!

イテレータの型はコンテナごとに定義されていて複雑なため，基本的には`auto`を使う。  

```
vector<int> a = {1, 2, 3};
auto itr1 = a.begin();
set<int> b = {4, 5, 6};
auto itr2 = b.begin();
// itr1とitr2は別の型

```
これ別の型になるんだね。てっきりint型になるかと思ってたので注意！！

### 先頭の要素のイテレータ

`コンテナ.begin()`  
コンテナの先頭の要素を返す。コンテナが空の場合は，「末尾の要素の次」を指す。

### 終端のイテレータ

`コンテナ.end()`  
※注意！！  
コンテナの終端(最後の要素の次)
