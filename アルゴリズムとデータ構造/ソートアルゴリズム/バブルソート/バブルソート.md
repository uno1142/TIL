# バブルソート
バブルソートはその名の通り泡が水面に上がっていくように配列の要素が動いていく。  
順番が逆になっている隣接要素がなくなるまで、次の処理を繰り返す。
1. 配列の末尾から隣接する要素を順番に比べていき、大小関係が逆ならば交換する。  
<br>
挿入ソートと同様に、各計算ステップにおいて配列は「ソート済みの部分列」と「未ソートの部分列」とに分けられる。

## 実装

```
int bubbleSort(int A[], int N ){
  int sw = 0; //カウント変数
  bool flag = 1;
  for(int i =0; flag; i++){ //フラグがtrueの間繰り返す。i++でソート済みの部分列の先頭が配列の後ろへ進んでいく。
     flag = 0; //交換がなくなったらループを抜ける
     for (int j = N -1; j >= i; j--){ //jがi以上の時に繰り返し、jを減らしていく（先頭に向かっていき、ソート済み部分列の先頭に来たら終わる）
       if (A[j] < A[j - 1]){
       //隣接要素を交換する
       swap(A[j], A[j - 1]);
       flag = 1; //交換したのでもう一度ループする
       sw++;
       }
     }
  }
  return sw;
}

```

バブルソートの実装に必要な変数
- A[N]
- i 未ソートの部分の先頭を指すループ変数で、配列の先頭から末尾に向かって移動する
- j 未ソートの部分の隣り合う要素を比較するためのループ変数で、Aの末尾であるN-1から開始しi+1まで減少する

## バブルソートの計算量

バブルソートは配列要素の隣同士のみを比較・交換するので(==離れた要素を直接交換しない)安定なソート。  
ただし隣同士を比較する演算A[i] < A[i - 1]に等号を入れてしまうと安定ではなくなるので注意。  
<br>
計算量を考える。データの数をNとすると、バブルソートは未ソートの部分列における隣同士の比較をN-1回,N-2回…1回の  
合計(N<sup>2</sup> - N)/2回の比較演算が行われるため、O(N<sup>2</sup>)のアルゴリズムである。  
<br>
なお、バブルソートの交換回数は反転数または転倒数と呼ばれ、列の乱れの具合を示す数値として知られている。(例sw)
