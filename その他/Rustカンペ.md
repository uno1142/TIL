はい、では今回もトップバッターということでやらせていただきます。よろしくお願いいたします。

なんか入社してからかれこれ3回目のTECH CANFなんですけどなぜか毎回テーマ違うのにトップバッターなんですよね。理由があるのかはわからないんですけどやらせていただきます。

 そんなことはさておきさっそくですがプログラミング言語RUSTということで早速Cargo RUN　させていただこうと思います！

ちなみにcargo run というのはRsutの実行コマンドで、これ叩いてあげるとRustのプログラムが実行される

まず初めに今回の流れなんですが、まずこういうアプリケーションを作りました！っていう感じの発表ではなくて、 そもそもこれってどんな言語なの？何が得意なの？といったところから、簡単なインストールしてプロジェクト作って動かしてみたいな ご紹介をする方針で進めていきます。

では最初、Rustはどんな言語ということこからですね。

Rustってどんな言語？
Rustというのは、Firefoxなんかで有名なMozilla社が開発して2015年にリリースした比較的新しめの言語です。開発がはじまったのが2006年からとかですね。リリースが2015年。7年前ですね。 StackOverflowという技術系の有名なサイトがあってみなさんも１度くらいはアクセスしたことあると思うんですけど、 そちらのサイトで毎年開発者が選ぶ「もっとも好きなプログラミング言語」というランキング、Stack Overflow Developer Surveyというのがあるんですけど、そこで6年連続1位を取得しているめちゃくちゃ愛されているプログラミング言語になります。

で、大きな特徴としては、すごく早いです、この言語。 実行速度が、最速ともいわれる元祖Ｃ言語や、C++言語、こちらと肩を並べています。とにかく早いのでWebのバックエンドとかあとは組み込み系で 結構注目されているようですね。

で、最大の特徴が、早いにもかかわらず、ガベージコレクションなしでメモリ安全性が担保されています。

どういうことかっていうと、 今までの言語っていうのは、CとかC＋＋みたいに早い代わりに、メモリ周りがちょっと危険だ、難しい、といった言語や、 逆にちょっと遅くなるけど、ガベージコレクションとかで面倒なメモリの管理はプログラムの方がやってくれますよ、といった簡単なかわりに速度が落ちるガベージコレクション採用の言語、というのがほとんどだったんですが、

Rustは、高速でメモリ安全なのに、ガベージコレクションを使用していません。全く新しいアプローチの仕方をしているので、注目されていて、かつ 人気投票１位ですから、受けてもいる、という言語になります。

(スライド)

ただ、人気っていう割には、そこまで名前聞かないよ。どんな製品が使ってるの？って話になってくると思うんですね。 そうなったときに、理由がありまして、習得難易度がとても高いです。 スペックだけ見ると最強なんですが、書いたり一人前のRustプログラマになる、となるとかなりハードルが高いのが原因でまだ そこまで広くは浸透していないという状況のようです。ただコミュニティがすごく活発で、あと数年待てばもっとライブラリとかsdkとか充実してくるんじゃないかなんて言われてます。現状これでアプリ組もうとすると外部のsdk使いたいってなったときにまだ対応してないことが多いらしく、自分で実装しなきゃいけないとか、そういった部分の問題はあるみたいですね。

とはいえ、有名なサービスでも使ってるところでは使っていまして、Firefox、まあここは開発元なのでわかるんですけども、 あとはDropbox, Cloudflare, AWSの一部でも既に使われていて世の中で活躍しています。

なので、既存の言語ほど広く使われてるってわけではないですが、目を付けてるところはどんどん使っていってる注目の言語と言えると思います。

（スライド） じゃあ難しいってことはコストがかかるという事になると思うんですけど、採用するメリットは？というと、 先ほどあげた早くてメモリ安全というのはもちろんなんですけど、Rustでは「No Rust 2.0」というのを掲げていまして、 Rustのバージョン2.0は来ないよってことなんですが、今書いたRustのコードは将来のRustコンパイラでも必ずコンパイルできる というのが公約として挙げられています。

よくある言語だと、バージョンアップに伴って古い関数使えなくなったりとか、警告出てきたり、C#でも多いですよね。バージョンアップにより非推奨になりました。みたいなちょっと鬱陶しいアレです。あれがなかったり、それに伴って処理の一部を変える必要があったりとかしがちだと思うんですが、 それがないということですね。今後数年とかじゃなく、今何十年と使われているCやC＋＋のように、何十年も依存できる信頼性の高いプログラミング言語というのを目指しているみたいです。ポストC言語の座を虎視眈々と狙ってるって感じです。

(スライド)

あとはパッケージマネージャーがすごい優秀です。後から有能さを見せようと思ってるんですが、オープンソースのパッケージとかを簡単利用できます。 CとかC++だと
※ここに関して補足説明する


ではひとまず概要についてはここまでにして、実際にRustを動かしてみようと思います。 で、インストールなんですけど、インストーラ落としてきて実行すれば一瞬で終わります。一応VisualStudioインストールしてる方だとすごく簡単です。

一応今回はもうインストールしてあるんですけど、cmdだして rustc --versionでインストールできてるか確認できます。 あとはrustup updateでアップデートできますね

では早速適当なフォルダにプロジェクトつくってみます。 cargo new hoge_fugaでプロジェクト名指定します。 Rustでは基本プロジェクト名はスネークケースで書きます。今回はrust-lessonとでもしておきましょうか。

これでもうプロジェクトできているので見ていきます

まずこのCargo.tomlってのがあるんですけど、ここcsprojctみたいな感じです 先ほどのプロジェクト名がここに入ってます

で、メインのコードは src の中の main.rs　ここに全部書きます。

じゃあちょっと簡単にコード書いてみます

let _x = 10;
let _y = 20;

println!("{} , {}", x, y);

※こっから
こんな感じで、rustでは変数を定義するとき、letで定義します。 実行すると、10, 20と出てきますね。
rustではこんな感じでletを使って変数宣言します。型推論が効きます。


では早速rustコンパイラの優秀なところを見せていこうと思うんですけども、一旦printlnの行をコメントアウトしてみます。 
これでcargo runしてみましょう。 すると、警告出てくるんですね。Rustって使ってない変数にちょっと厳しくて、 明示的に、意味を持って使わないけど宣言してるんだよという場合は、頭にあんだーばーをつけなさいという風に怒られます。

Rustはこういうのがすごく多くて、鬱陶しいと感じる方もいれば、誰が書いてもある品質が保たれるっていう点で、すごい好きな人も多いような言語になってます。

では次に変数の操作してみますね。

x = x + 20を代入してみます。これでcargo runと はい、がっつりコンパイルエラーです。 エラーメッセージ見てみると、cannot assign twice to immutable variableとあります。 immutable,不変な値に2回目は割り当てられないよということですね。

そうです。rustでは、letで変数定義するとき、デフォルトではその値はimmutable、不変として定義されます。なので、こういう風に後程値を変えたいような変数を使うときは、

let mut x = 10; というような形で、明示的にこの値は「可変ですよ」という宣言をしてあげる必要があります。

じゃあこれ入れてみましょう。cargo run

はいビルドは通ったんですけど警告です。 value assigned to x is never read 割り当てられた値が読み込まれてないよと書いてあります。 これ10入れた意味あるの？ってことですね。なんて優秀なんでしょうか。cargoのコンパイラ、 めちゃくちゃ細かく教えてくれます。

実装段階でこういう些細なミスも教えてくれるので、プルリク出すころにはだいぶ綺麗になってますよね。確認してもらう方の時間を無駄に奪ったりもし辛いです。さきほどからメッセージも２行目と5行目だよーとか、親切に書いてくれるので、動けばいいんだよ！！って方には鬱陶しいかもしれないですけど、私は結構これバグなおしやすくてかなり好きですね。直しやすいです。コンパイラが本当に好きです。

で、一応こうやって普通の他の言語みたいに可変の変数を使えるようにはしているんですけど、 デフォルトがImmutableってことで、一応推奨はImmutableの方です。

Rustでは、値が不変であると宣言したら、本当に変わらないことをコンパイラが担保してくれます。 つまり、コードを読み書きする際に、どこでどうやって値が変化しているかを追いかける必要がなくなります。 なのでコードを通して正しいことを確認するのが簡単になるのです。

ここまで話を聞いて、いやいや、こんなのやりにくいから変数全部let mutにしちゃうよと思った方もいると思うんですけど、そこでrustではシャドーイングっていう仕組みが用意されています。

それが、こういう感じで、同じ変数名でletを使うことができるというものになります。

まず、rustって変数を代入することを値をバインドする、束縛するという風に言うんですけど、 この最初の let x = 10で、xという変数に10という値が束縛されます。 で、その後再度let で　、xという新しい変数が出てくるわけですよね。なので、ここで変数xの10にバインドされたものは、新しく、20 + 20でバインドされた新しい変数xに覆い隠されるというイメージです。

なんでこんな仕組みになってるんだ？と思いますよね。実はこれ、いろいろ理由はあるんですけど、例えば変数名のために用意されてる仕組みになります。

例えば、 プログラムがユーザに何らかのテキストに対して空白文字を入力してきます。と。 ただ、実際にはこの入力をスペースではなくて数値として保持したいとしましょう

let spaces = "       ";
let spaces_length = spaces.len();

println!("str:{}, usize:{}", spaces, spaces_length);
で、スペースの入力もらって、数字として保持したいんだけど、あくまで欲しいデータって空白が何個あるか、であって、空白の連続した文字列いらないですよね。 その区別させるために、わざわざspace_lengthとか、spaces_numとか、余計な変数定義することって往々にしてあると思うんですよ。

それを、rustでは

let spaces = "       ";
let spaces = spaces.len();

println!("{}", spaces);
spacesっていうよりシンプルな変数名を別のデータ型でも使うことができるんですね。
一方で、先ほど説明したmutとは違う点が大きくあって、mutの変数は、型を変えることはできないんですね。同じ型でのみ値を入れ替えることができるんですけど、
シャドーイングはintに使ってた変数をstringとかに変えられるんですが、mutの変数はコンパイラに怒られます。

だいたい基本的な挙動のお話はこの辺になります。

//ここまではかってみる


でもう一個
あとRUSTの特徴の１つなんですけど、結構警告メッセージが親切です。発生した行も教えてくれますし、C++とかだと、配列の範囲外参照とか未定義動作になるコードを実行したときに、警告出ないパターンとかあるんですよ。Rustはめっちゃしっかり怒ってくれますし、何行目で起きてるかも教えてくれるんですね。

ちょっと試してみますね。普通にプログラムに直接存在しないインデックスいれてもその時点で怒られるだけなんで、入力受け取ってやる形にします。 ちょっと全部説明してると時間が足りないのでこの辺のコーディングはささっとやります。


```
use std::io;
pub fn run(){
    let array = [1,2,3,4,5];
    let mut index = String::new();

    println!("indexを指定してください");
    
    io::stdin().read_line(&mut index).expect("failed");
    let index: usize = index.trim().parse().expect("not num");

    let x = array[index];

    println!("値：{}", x);
}
```

じゃあこんな感じで書いて動かしてみます。 まずは１入れてみますね。はい。1だと正常に動きます。 では次に5、この配列indexが4までしかないので、C++とかだと範囲外参照になりますね。 わけわからんところのメモリ見に行っちゃいます。 はい。エラー出ました。しかも、25行目でエラー出てますよってのを教えてくれますね。

ちょっとこれ試しにC++だとどうなるかってのをお見せします。 環境構築してないんでWebコンパイラになるんですけど

#include<vector>
#include<iostream>
#include<string>
#include<cstring>
using namespace std;

int main()
{
  int arr[] = {1,2,3,4,5};
  
  int a;
  cin >> a;
  
  cout << arr[a] << endl;
}

これに1入れるとまあ2が出てきてくれるんですけど、5を入れるとですね エラー出ないんですよ。で、しかも配列の範囲外なので、めちゃくちゃな値が出てきます。 今回は簡単なコードなのでいいんですけど、例えばこれがすごい大きなプロジェクトで、しかもこの値を使って加工していくようなシステムとかになっちゃうと、どこで発生してるかってすぐにわからなかったり、原因がわからなかったりとか、大変なことになる可能性があるんですね。

口うるさいと感じる方もいると思うんですけど、こういう警告があるので、誤ったコードを書いたときに修正しやすいっていうのと、誰が書いても一定の品質が保たれるってのはいいところですよね あとここまで頻繁にcargo run実行してるんですけど、動作速いですよね。 C#とかだったら同じの実行するにもちょっとビルドの時間かかったりすると思うんですが、サクサク動くので快適にいろんなコード試せますね。

さてまあここまではrustのコンパイラの紹介って感じだったんですけど、
一番の目玉機能というか、核になる部分のお話を仕様と思います。
それが所有権というものなんですが、rustの各値には、「所有者」と呼ばれる変数が対応していまして、この所有者っていうのは常に１つである。
所有者がスコープから外れたら、値は破棄される。

というものなんですが、まあ口で説明してもまずわからないと思います。そもそもがだいぶ難解で私もここで挫折しかけたんですけど、
実際にコード見てもらったほうが早いと思います。

まずrustっていうのは、値のスコープが外れた時、今回の例だと、メイン関数を抜けた時、dropっていう関数が内部的に呼ばれます。各値に対してですね。
これはコードには書いてないんですけど勝手にメモリを解放してくれるっていうものですね。

ただこれCとかでもやろうとすると危ないパターンがあって、メモリの二重解放エラーっていうのが起きてしまう可能性があるんですよ。
C++とか触ったことある方だと恐ろしさをなんとなくイメージできると思うんですけど、値が格納されているメモリを二回解放してしまうっていう危険性ですね。

例えば変数Aさんが、ポインタの1っていう番地にある値を格納しているとします。
で、同時に変数Bさんも、ポインタの１っていう番地にある値を格納してるとします。

この状態でAさんとBさんが同時にスコープから抜けました。
で、それと同時にCさんが新しいおうちを探そうとしていたので、たまたまAさんとBさんが出ていく１っていう番地に住むことにしました。

その時に、マルチスレッドのプログラムとかでこれが起きると、
Aさんで１番地を解放したあとに、あ、空いてるじゃん！って入ってきたＣさんが入った直後にBさんが、もう家は空けてあるのに、
さらにその家を解放しようとするんですよ。メモリの領域ですね。解放処理でＣさんの値も解放してしまうっていうことが
起きる可能性があるんですね。

そうなってしまうと、当然プログラムぐちゃぐちゃになります。想像しただけで怖いですよね。正確にはその１番地って感じじゃなくて、
メモリの先頭のアドレスのポインタとかを持ってて、そこからどこまでを解放する、みたいな感じになるんですけど。とにかくまずいと。

なのでそれを避けるために、考えられたのが所有権というシステムになりまして。
1番地に住める人はAさんだけにしましょう。でもBさんもそこの値使いたいんですよね。
では、Bさんは、Aさんが所有しているので、Aさんから借りて使ってください。と。

で、Aさんがスコープから出ていったら、Bさんも使えなくなりますよ、というようなことにしたのが所有権っていうシステムなんですね。

じゃあちょっとコードで見ていきますね。
まず、s1っていうのをstring型で定義します。このstring型っていうのが所有権が適用される型になりまして、
s1っていうのがいま所有権を持っている形になります。

```
let s1 = String::from("hello");
    let s2 = s1;

    println!("{} , {}" , s1, s2);
```

let s2 = s1としてみます。
で、これをprintで出力しようとします。

はい、ビルドエラーです。ここはs1の所有権はすでにs2に移動しているのでs1にアクセスできません、と書いてます。
この時点で、"hello"っていうデータの所有権はもうs2に移動しているということですね。

ただこれのおかげで、解放するときにもうs1はこのHelloが入ってるメモリの解放はs1はしないっていうことになるので、
s1は自身の情報だけ、s1っていう変数に、番地Xから何メモリまでのデータを格納していましたっていう情報のほうはdropするんですが、
s1がみていた実データのメモリの情報は無視されます。

で、s2は、自身のデータに加えて、所有権がある実データのアドレスから何メモリかっていう確保してた領域までの情報をdropします
というような流れですね。
でまあこういう感じでメモリ安全性を出してますよっていう言語で、実際にツールでも作ってみようかなと思って挑戦していたんですが、
想定よりも難しくてですね、今コンパイルエラーで動かない状態です。
