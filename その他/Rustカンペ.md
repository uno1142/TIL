はい、では今回もトップバッターということでやらせていただきます。よろしくお願いいたします。

なんか入社してからかれこれ3回目のTECH CANFなんですけどなぜか毎回テーマ違うのにトップバッターなんですよね。理由があるのかはわからないんですけど
そんなことはさておきさっそくですがプログラミング言語RUSTということで早速Cargo RUN　させていただこうと思います！

ちなみにcargo run というのはRsutの実行コマンドで、これ叩いてあげるとRustのプログラムが実行される

まず初めに今回の流れなんですが、まずこういうアプリケーションを作りました！っていう感じの発表ではなくて、
そもそもこれってどんな言語なの？何が得意なの？といったところから、簡単なインストールしてプロジェクト作って動かしてみたいな
ご紹介をする方針で進めていきます。

では最初、Rustはどんな言語ということこからですね。

# Rustってどんな言語？

Rustというのは、Firefoxなんかで有名なMozilla社が開発して2015年にリリースした比較的新しめの言語です。開発がはじまったのが2006年からとかですね。リリースが2015年。7年前ですね。
StackOverflowという技術系の有名なサイトがあってみなさんも１度くらいはアクセスしたことあると思うんですけど、
そちらのサイトで毎年開発者が選ぶ「もっとも好きなプログラミング言語」というランキング、Stack Overflow Developer Surveyというのがあるんですけど、そこで6年連続1位を取得しているめちゃくちゃ愛されているプログラミング言語になります。

で、大きな特徴としては、すごく早いです、この言語。
実行速度が、最速ともいわれる元祖Ｃ言語や、C++言語、こちらと肩を並べています。とにかく早いのでWebのバックエンドとかあとは組み込み系で
結構注目されているようですね。

で、最大の特徴が、早いにもかかわらず、ガベージコレクションなしでメモリ安全性が担保されています。

どういうことかっていうと、
今までの言語っていうのは、CとかC＋＋みたいに早い代わりに、メモリ周りがちょっと危険だ、難しい、といった言語や、
逆にちょっと遅くなるけど、ガベージコレクションとかで面倒なメモリの管理はプログラムの方がやってくれますよ、といった簡単なかわりに速度が落ちるガベージコレクション採用の言語、というのがほとんどだったんですが、

Rustは、高速でメモリ安全なのに、ガベージコレクションを使用していません。全く新しいアプローチの仕方をしているので、注目されていて、かつ
人気投票１位ですから、受けてもいる、という言語になります。

(スライド)

ただ、人気っていう割には、そこまで名前聞かないよ。どんな製品が使ってるの？って話になってくると思うんですね。
そうなったときに、理由がありまして、習得難易度がとても高いです。
スペックだけ見ると最強なんですが、書いたり一人前のRustプログラマになる、となるとかなりハードルが高いのが原因でまだ
そこまで広くは浸透していないという状況のようです。ただコミュニティがすごく活発で、あと数年待てばもっとライブラリとかsdkとか充実してくるんじゃないかなんて言われてます。現状これでアプリ組もうとすると外部のsdk使いたいってなったときにまだ対応してないことが多いらしく、自分で実装しなきゃいけないとか、そういった部分の問題はあるみたいですね。


とはいえ、有名なサービスでも使ってるところでは使っていまして、Firefox、まあここは開発元なのでわかるんですけども、
あとはDropbox, Cloudflare, AWSの一部でも既に使われていて世の中で活躍しています。

なので、既存の言語ほど広く使われてるってわけではないですが、目を付けてるところはどんどん使っていってる注目の言語と言えると思います。


（スライド）
じゃあ難しいってことはコストがかかるという事になると思うんですけど、採用するメリットは？というと、
先ほどあげた早くてメモリ安全というのはもちろんなんですけど、Rustでは「No Rust 2.0」というのを掲げていまして、
Rustのバージョン2.0は来ないよってことなんですが、今書いたRustのコードは将来のRustコンパイラでも必ずコンパイルできる
というのが公約として挙げられています。

よくある言語だと、バージョンアップに伴って古い関数使えなくなったりとか、警告出てきたり、C#でも多いですよね。バージョンアップにより非推奨になりました。みたいなちょっと鬱陶しいアレです。あれがなかったり、それに伴って処理の一部を変える必要があったりとかしがちだと思うんですが、
それがないということですね。今後数年とかじゃなく、今何十年と使われているCやC＋＋のように、何十年も依存できる信頼性の高いプログラミング言語というのを目指しているみたいです。ポストC言語の座を虎視眈々と狙ってるって感じです。

(スライド)

あとはパッケージマネージャーがすごい優秀です。後から有能さを見せようと思ってるんですが、オープンソースのパッケージとかを簡単利用できます。
CとかC++だと

ではひとまず概要についてはここまでにして、実際にRustを動かしてみようと思います。
で、インストールなんですけど、インストーラ落としてきて実行すれば一瞬で終わります。すごく簡単です。

一応今回はもうインストールしてあるんですけど、cmdだして rustc --versionでインストールできてるか確認できます。
あとはrustup updateでアップデートできますね

では早速適当なフォルダにプロジェクトつくってみます。
cargo new hoge_fugaでプロジェクト名指定します。
Rustでは基本プロジェクト名はスネークケースで書きます。書かないと警告出されて鬱陶しいのでおとなしくスネークケースで書きます。

これでもうプロジェクトできているので見ていきます

まずこのCargo.tomlってのがあるんですけど、ここcsprojctみたいな感じです
先ほどのプロジェクト名がここに入ってます

で、メインのコードは
src の中の main.rs　ここに全部書きます。

じゃあちょっと簡単にコード書いてみます

```
let _x = 10;
let _y = 20;

println!("{} , {}", x, y);

```

こんな感じで、rustでは変数を定義するとき、letで定義します。
実行すると、10, 20と出てきますね。

ただこれ注意点があって、一旦printlnの行をコメントアウトしてみます。
これでcargo run すると、警告出てくるんですね。Rustって使ってない変数にちょっと厳しくて、
明示的に、意味を持って使わないけど宣言してるんだよという場合は、頭にあんだーばーをつけなさいという風に怒られます。

Rustはこういうのがすごく多くて、鬱陶しいと感じる方もいれば、誰が書いてもある品質が保たれるっていう点で、すごい好きな人も多いような言語になってます。

では次に変数の操作してみますね。

x = 30を代入してみます。これでcargo runと
はい、がっつりコンパイルエラーです。
エラーメッセージ見てみると、cannot assign twice to immutable variableとあります。
immutable,不変な値に2回目は割り当てられないよということですね。

そうです。rustでは、letで変数定義するとき、デフォルトではその値はimmutable、不変として定義されます。なので、こういう風に後程値を変えたいような変数を使うときは、

let mut x = 10;
というような形で、明示的にこの値は「可変ですよ」という宣言をしてあげる必要があります。

じゃあこれ入れてみましょう。cargo run

はいビルドは通ったんですけど警告です。
value assigned to `x` is never read
割り当てられた値が読み込まれてないよと書いてあります。
これ10入れた意味あるの？ってことですね。なんて優秀なんでしょうか。cargoのコンパイラ、
めちゃくちゃ細かく教えてくれます。

実装段階でこういう些細なミスも教えてくれるので、プルリク出すころにはだいぶ綺麗になってますよね。確認してもらう方の時間を無駄に煩わせたりもし辛いです。さきほどからメッセージも２行目と5行目だよーとか、親切に書いてくれるので、動けばいいんだよ！！って方には鬱陶しいかもしれないですけど、私は結構これバグなおしやすくて好きですね。直しやすいです。

で、一応こうやって普通の他の言語みたいに可変の変数を使えるようにはしているんですけど、
デフォルトがImmutableってことで、一応推奨はImmutableの方です。


Rustでは、値が不変であると宣言したら、本当に変わらないことをコンパイラが担保してくれます。 つまり、コードを読み書きする際に、どこでどうやって値が変化しているかを追いかける必要がなくなります。 なのでコードを通して正しいことを確認するのが簡単になるのです。

ここまで話を聞いて、いやいや、こんなのやりにくいから変数全部let mutにしちゃうよと思った方もいると思うんですけど、そこでrustではシャドーイングっていう仕組みが用意されています。

それが、こういう感じで、同じ変数名でletを使うことができるというものになります。

まず、rustって変数を代入することを値をバインドする、束縛するという風に言うんですけど、
この最初の let y = 20で、yという変数に20という値が束縛されます。
で、その後再度let で　、yという新しい変数が出てくるわけですよね。なので、ここで変数yの20にバインドされたものは、新しく、20 + 20でバインドされた新しい変数yに覆い隠されるというイメージです。

なんでこんな仕組みになってるんだ？と思いますよね。実はこれ、安全性だけじゃなくて、変数名のためにも用意されてる仕組みになります。

例えば、 プログラムがユーザに何らかのテキストに対して空白文字を入力してきます。と。
ただ、実際にはこの入力をスペースではなくて数値として保持したいとしましょう

```
let spaces = "       ";
let spaces_length = spaces.len();

println!("str:{}, usize:{}", spaces, spaces_length);
```

で、スペースの入力もらって、数字として保持したいんだけど、あくまで欲しいデータって空白が何個あるか、であって、空白の連続した文字列いらないですよね。
その区別させるために、わざわざspace_lengthとか、spaces_numとか、余計な変数定義することって往々にしてあると思うんですよ。

それを、rustでは
```
let spaces = "       ";
let spaces = spaces.len();

println!("{}", spaces);
```

これができます。これは正常な構文として扱われます。
何がいいかっていうと、spacesっていうよりシンプルな変数名を別のデータ型でも使いまわすことができるんですね。
しかも、最新の定義されてる箇所を見れば、なんの型なのか、なんの値が入ってるのか、
そこから再定義されるまでは値が不変なことが約束されているので、安心して入ってる値を信用できるんですね。

逆に、mutableの変数をletでimmutableにはできます。
なので入力受け取るときとかは可変で受け取り用の文字列とかで用意してあげて、
letで使いたい型に固定しちゃえばいいです。

まだ実感しづらいと思うんですが、この変数が勝手に書き換わらないっていうのはすごい良いところだなと個人的には感じております。バグったとしても、そっからその手前でシャドーイングで上書きされてる、letのとこまでの間を見ればいいので、原因が見つけやすいです。

あとRUSTの特徴の１つなんですけど、結構警告メッセージが親切です。発生した行も教えてくれますし、C++とかだと、配列の範囲外参照とか未定義動作になるコードを実行したときに、警告出ないパターンとかあるんですよ。Rustはめっちゃしっかり怒ってくれますし、何行目で起きてるかも教えてくれるんですね。

ちょっと試してみますね。普通にプログラムに直接存在しないインデックスいれてもその時点で怒られるだけなんで、入力受け取ってやる形にします。
ちょっと全部説明してると時間が足りないのでこの辺のコーディングはささっとやります。


```
use std::io;

~~~
~~~

println!("indexを指定してください");
io::stdin().read_line(&mut index).expect("failed");
let index: usize = index.trim().parse().expect("not num");

let x = array[index];

println!("値：{}", x);

```

じゃあこんな感じで書いて動かしてみます。
まずは１入れてみますね。はい。1だと正常に動きます。
では次に5、この配列indexが4までしかないので、C++とかだと範囲外参照になりますね。
わけわからんところのメモリ見に行っちゃいます。
はい。エラー出ました。しかも、25行目でエラー出てますよってのを教えてくれますね。

ちょっとこれ試しにC++だとどうなるかってのをお見せします。
環境構築してないんでWebコンパイラになるんですけど

```
#include<vector>
#include<iostream>
#include<string>
#include<cstring>
using namespace std;

int main()
{
  int arr[] = {1,2,3,4,5};
  
  int a;
  cin >> a;
  
  cout << arr[a] << endl;
}

```

これに1入れるとまあ2が出てきてくれるんですけど、5を入れるとですね
エラー出ないんですよ。で、しかも配列の範囲外なので、めちゃくちゃな値が出てきます。
今回は簡単なコードなのでいいんですけど、例えばこれがすごい大きなプロジェクトで、しかもこの値を使って加工していくようなシステムとかになっちゃうと、どこで発生してるかってすぐにわからなかったり、原因がわからなかったりとか、大変なことになる可能性があるんですね。

口うるさいと感じる方もいると思うんですけど、こういう警告があるので、誤ったコードを書いたときに修正しやすいっていうのと、誰が書いても一定の品質が保たれるってのはいいところですよね
あとここまで頻繁にcargo run実行してるんですけど、動作速いですよね。
C#とかだったら同じの実行するにもちょっとビルドの時間かかったりすると思うんですが、サクサク動くので快適にいろんなコード試せますね。

